package comp.jls;

import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "java12.grammar".
 */
public class JavaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short LPAREN = 2;
		static public final short BOOLEAN = 3;
		static public final short BYTE = 4;
		static public final short SHORT = 5;
		static public final short INT = 6;
		static public final short LONG = 7;
		static public final short CHAR = 8;
		static public final short FLOAT = 9;
		static public final short DOUBLE = 10;
		static public final short PLUSPLUS = 11;
		static public final short MINUSMINUS = 12;
		static public final short SUPER = 13;
		static public final short THIS = 14;
		static public final short NEW = 15;
		static public final short VOID = 16;
		static public final short INTEGER_LITERAL = 17;
		static public final short FLOATING_POINT_LITERAL = 18;
		static public final short BOOLEAN_LITERAL = 19;
		static public final short CHARACTER_LITERAL = 20;
		static public final short STRING_LITERAL = 21;
		static public final short NULL_LITERAL = 22;
		static public final short PLUS = 23;
		static public final short MINUS = 24;
		static public final short SEMICOLON = 25;
		static public final short COMP = 26;
		static public final short NOT = 27;
		static public final short RPAREN = 28;
		static public final short LBRACE = 29;
		static public final short SYNCHRONIZED = 30;
		static public final short LBRACK = 31;
		static public final short FINAL = 32;
		static public final short DOT = 33;
		static public final short WHILE = 34;
		static public final short RBRACE = 35;
		static public final short DO = 36;
		static public final short FOR = 37;
		static public final short IF = 38;
		static public final short SWITCH = 39;
		static public final short BREAK = 40;
		static public final short CONTINUE = 41;
		static public final short RETURN = 42;
		static public final short THROW = 43;
		static public final short TRY = 44;
		static public final short PUBLIC = 45;
		static public final short PROTECTED = 46;
		static public final short PRIVATE = 47;
		static public final short STATIC = 48;
		static public final short ABSTRACT = 49;
		static public final short NATIVE = 50;
		static public final short TRANSIENT = 51;
		static public final short VOLATILE = 52;
		static public final short STRICTFP = 53;
		static public final short COMMA = 54;
		static public final short ELSE = 55;
		static public final short RBRACK = 56;
		static public final short CLASS = 57;
		static public final short COLON = 58;
		static public final short EQ = 59;
		static public final short LSHIFT = 60;
		static public final short RSHIFT = 61;
		static public final short URSHIFT = 62;
		static public final short MULTEQ = 63;
		static public final short DIVEQ = 64;
		static public final short MODEQ = 65;
		static public final short PLUSEQ = 66;
		static public final short MINUSEQ = 67;
		static public final short LSHIFTEQ = 68;
		static public final short RSHIFTEQ = 69;
		static public final short URSHIFTEQ = 70;
		static public final short ANDEQ = 71;
		static public final short XOREQ = 72;
		static public final short OREQ = 73;
		static public final short MULT = 74;
		static public final short INTERFACE = 75;
		static public final short CASE = 76;
		static public final short DEFAULT = 77;
		static public final short EXTENDS = 78;
		static public final short THROWS = 79;
		static public final short FINALLY = 80;
		static public final short DIV = 81;
		static public final short MOD = 82;
		static public final short LT = 83;
		static public final short GT = 84;
		static public final short LTEQ = 85;
		static public final short GTEQ = 86;
		static public final short INSTANCEOF = 87;
		static public final short IMPORT = 88;
		static public final short CATCH = 89;
		static public final short IMPLEMENTS = 90;
		static public final short EQEQ = 91;
		static public final short NOTEQ = 92;
		static public final short AND = 93;
		static public final short XOR = 94;
		static public final short OR = 95;
		static public final short ANDAND = 96;
		static public final short PACKAGE = 97;
		static public final short QUESTION = 98;
		static public final short OROR = 99;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjVGTybCNp$inUUWA4dWDY222A1WMLq4GGLAIBg2WMx0eeY691AQA2XMh3XWKnTAdIYoX" +
		"DK10H1AKflHS55C5tVy$kkxaUkFSuli3$dxlFlBFllZippypkpkxxvkv2LFfxNacNqAKyWE" +
		"RGSlgHVn8bw2rUpD$n4bvAxz7xz3gzmT$pGbv41JXEt4BFyWAEvmHEv2HEvXGkm0Mv4AToO" +
		"SwWosWhty63k1RVmesuERVWcxWbtyojk0tVoNVntNmFj#Lx#Jw#dn$W5PJ4lRW9rU36t5Gq" +
		"4jVnAhwHMjAtj95#fysYiMWY4YcBVw2vj89#efNqCwsYrVGBtKltKp$wW2RIQ9f6qsa6pQH" +
		"PD3lG5teiJrzQqG9QftonIw8fRHUr85lJbgLjV5qaleW6oXVv1sJX2zUYAxp#y8iyt072Wj" +
		"O4cQaGMXD2lScYp8YYBHL2giGzTBHJk9uFme$e9UfbHqJEufyTeBt06ayLDDhneTxqOeHZe" +
		"xL6svfIDThlQ0rLLqSkGTVpHtOhIg1iYdU4rjlxsxMCfzVfSegZYrHTH6YtAhIGkKgZjQrK" +
		"5SsqZUl3nyT5u74XZS$6eZo#KiuKwIADEj98lfI6HuIleiRtktoH6s9qXX#lSYARBmuPhnO" +
		"qZoxarVphQSMhkZCyubOTbH1uv4owbHRHG$JmQU5fxJ0#6UYnSdd6foCLYN2k#kDvCFnCQ1" +
		"sXT1v88p6UXtDt$f7gy6tKdJlnXpo4k$0Z$1OFun4ycYVpL7wPN#7Ut8TVvTUvB$VZ$auig" +
		"Rw79HNrL3zBcyAnH2$edlp2nElBayo9ydgKgTMdOb2KOTsIL9RswnXle6Jkm7jE7cDHZlRH" +
		"qxoHaQjfhtLOpLhWVapkuBsyZ$Vp0KTHYE7t4ONkl4vkLr6GCn05WIZK3YSAeXLNvSlbSig" +
		"oFWdqJNkjeZkIXzF5Q1DsnB1wPC4t5J7bM#1CgKUVyZModevOAQx83vygObJNpaQG$1TwU$" +
		"9ijRxndrmXDsBXOwEBgH9LzCuOsk71LPUkeYnPbolRlIbtyKMdxaskGFiWMGsuAjFVj4KUa" +
		"yVe0F$DcH5W6udtSBsMRSTxcxKDUv2B0aU2maRbgI5tF2MsRFH3eo3vO$83vzZu2hvMlgFZ" +
		"rWJpe1az3jsTGc6JzyaA$5GOsEmLPhV9SblblLIDBSJSUTogqHDqH6FBacb1c6QghCmRDBQ" +
		"BwKdkTafi7$1wSRqiIPDKPf5xw2bHXBUAU9vvgXag2ekKm1bAuwW$PkXpiXVwJEMfRdQU4i" +
		"dHpeYY1lM0fPVf5MgaBVM6fLTXAI7gbbfgdmRGcpHGMHBDOUbjP9qRecxfDdeNbfhG4CHD#" +
		"NGnB0tbJh9zj2rH3dfb88sWKJH6MneBI#DXgLtKBOsZPh0qcQRGL6sf4Yobef#I8bsvQ2bz" +
		"JyFeyznvGG$I7TI6sb87mif53UWtsa0xQHTzJHDeCFMbv#awgazNKotCucv1k4UA5WvcNmu" +
		"Tm5lFFgeTfAix7QA$a15LrZh65o3Rds8Fui3o2IPswNMcA1VdD2uB1DU4oabSXYz4leoUvI" +
		"nH0VS3od8bvEWgV1doVJNEu2nH3QKQk2FDaVzeoxToNMJ3g5dcEdoPiTo0wtCpMClan$aXp" +
		"k97kJq$mK$oq$oijdmxTqMkYvxb5xWdlwJxEOVVvBVvNHxCd$1x$2aFvS$v2ywHPNcajZoA" +
		"n$B7aLW#ZN4SNMsrhQ4ydYVo99w26TgTf$4CdiLpU2xAt$0ygkdawG3LnYfo2N$BotayijW" +
		"QwrFUpR$92sKbUP6yGzvErqOL$MkO1H#6ZUrEkbksfaUedRoDwb1dwX9bB9#SGjiFjCnNcx" +
		"oL3sbjDrEVg6Dn6fU6EYx4XsdGsSR2HmsMV#Ypiur5Ncsm7AUlpZOM$i$68Y$ZOcSRYo0RY" +
		"n2YuDcUHo96n6bjyqNHiur5NYeAQ6sRHAcpZKKK4gbQsnyY8xfO#CleQXF5H75HKhX56L5Q" +
		"N20oHLbHNbGK5ueh#BaeMkhAOwAAU#sv6rDwHboCEHrgLcS9LyYxZzgYZhXMpMhH52j#Tt4" +
		"JZhz45TCxBBIs$wAYxQEeOZiOLMt7epeoIaPLMxkeQkiSLMtlH5NRPr7LDY6gshwAghPbKT" +
		"Ls9AhQJZXTjqYzGcXZjwCd3tZnGAsBS2Sppdu6nvrm5lpauQ1ZlLK3zFwhzKh#oq#lCxnL$" +
		"FJQo4FZTQINB$6BGzJq1iJtREXrtc#1UaFts$zFUaysVfthhHWENiSxsUeXCi8DKSWhDvws" +
		"ZiOE$e9flzHJfRnVMn6lxUelc0wUqAauxr9wHLrFlxw1uskgBAVagkRje9swf9#qYde#ptI" +
		"VSV2Nynt1Vl0MKEud1OZYlNxmymwUkss67twQHSDGUrZU1Zz2Za715AFsi1vWiUPlBo5UyC" +
		"DvxrVqwVscJk#QITyres$gs7sZKQG3TKqVLC5FmLLjwTCQgSqZGufZ7P#0rJiD33UTXkmt4" +
		"QAFrETHshPJwL7s4n6dSjRdaM0zBIb7cILmfeUSITiZYxKaKLVkfazDnlfJpGfni$pAsc7j" +
		"e7zulfrPr6VKWZCM7HQnXDM5UfABlwR3denn8#tn0tUKfqFBvaWHdXzo#L9dJIgol7RBUU1" +
		"PlbI#rBaW5TaCMtWUUFQ$ZCVwyy2pVAbygND1Af8PTbj4KeiTIjtkiFrT3jlVux3zVGxRF#" +
		"2m$QCEsxTts7w9m$PhdRLdTlJf6Rpa9NvtLhkTojilMJ5YkV3ympqRVOnuXDsQOz6QgBgvP" +
		"$FrCIlei#PNcajfz2#NirjR4#qgQsAeDw#WqjnBNAERR5MjzEUnysWjwclTwkNsUBwEWbxY" +
		"1jIlzzNDjN4eJYMe99MYH8y7dgTjaAclwhcgk9hSg2$AhuLuebCO3Ok5#8pwvRcwSpMAosM" +
		"tG1loXH2VoGosaOMcWVrFl49S2Lykuwj5vT0jF3vT3UjLFP6eSlBMU9KHLmL7K7u8sKj55c" +
		"VZ95cK2wKb5nDQLXRbH2M$7hWeLul6b1s0wPGlSKaUzS24SQc#m$88Samxv8qE6BkFKqVgH" +
		"4zGPtgIdg8kz3GzGy$ISxI0QYFJTQFkL9VgqRLKdnhGTNGztK0DwKPgH1dmeozcLdyQG0Df" +
		"4Bs9MV0slKFlqc0z2px0AlGH3S6C#GHpuJCQYjan3BEcDWsd4PWl$J0Vnr0ht1NUYdMajOx" +
		"CP68IvA8OYgKuYgS4ZAiaIgOKAa05gH2bOXGLeQ9KJ8#Py7svckhGDTeNktHxaEp1Y7pPht" +
		"qXo2fVbApN7#LB#0WN8YxkaqGx1oCl4eJVQ8IC3AGGCltkXr15rOv8EhAYix6HVHAqDICS6" +
		"uqrsiP0ez2sf9kHNTNnVgoXapsjfg6L4xJUtW#KQOwiRTT5WhQlHgja55hRIb#ZRx83V0oF" +
		"l$B1fpoUWHZOOpw3fb3cQU0hRw8PFfuswDi38UDr9$PMKwafDOj2lCB7OxSCXISTwqQQpW$" +
		"$IpmBqMDjyenF8KGyihdgZyT99Yo3rcwCbEOOAUbq0QWipie1IGMwa2hIHVfxKMhNaaMLwJ" +
		"AwdAfGLRe2Uuwhg9eZIwhltJhgwH5O2Z$6SxKb5UFvGLBAUXdCc1mTuvd8DgUESHFi#BBr6" +
		"jmNER6CZd86ZKMynj5uce3TeRDu7z7nBkyJxys8meomel0tzeVBWPhfH91loclbNmQkPW9r" +
		"#15pGwAlZfZoBL3E3U$c0hUAM7d4zDGHopOwie6bBx3Cq7h7uYmtOk5Zo$HW2yQbSAlnQ$U" +
		"ce1PXOClGlPaDdLFHcmCWpRetEG9i6NXdQcogjnKnC0IE18LjB#ubJesjBEJR1icFXO$EiM" +
		"MZpz8rjdlGPtVhE798R6xe3mURl#rio6K3Muk8i0dJfqmt1M6wGqTofWDiQcwweMcApYoC#" +
		"IqqjZiYcg6PUBjf5pJTgsTepXdBYCsf1YnbwbvNbWGibJaZbjpQ9pLRXBQKUSPySckVxe6b" +
		"78#bC#DJ3Znm8nVMC9cq9YpLF2EMCZ5$L1PKAuUonB2KVWPMhgwaFlsXvaKFtCM$IBte9Vs" +
		"TpTxKXrwbr$Jd25Ms2yITWLrW#5PoTDwoPz#a4Bfge3P3pxv9z6qOiozyopNqg52MLInhuP" +
		"pfhv0vgJokHTCoqpRS3oZBsMOMCCupS3zmo9Hom9NbUU3HjBm8jcpBwVI7deDCrU7xD1q3c" +
		"zp6iZkgbiiWYaErvHmpUWzZpARhafiswVLpaycoqRKSpZYEhhP9niD#u6eDw4ShpNawreMT" +
		"6CTEvliaIAa#KNsJWxwgXVbUIqVDZRwh3ctHdjFXOrCxlEfKYahZc4uZQTHPxXSrbcrjqSS" +
		"IMLnKhvrzB6KCbkhd09Ryk8J68WmMzpamZzHEzqpD8#TpMfmpM5Jld2jOJgwjZDvb2zsJzf" +
		"6HeRUZz7LKBKLNMxIZ45rjvVL#ANXMCw8GQbRRQxwQrRVhwAlzrl5psiDyRVdQyhNzFwTDu" +
		"fM7DWUx5At5BVLBFtcmKPJ3MV2J1yTwgM$qzT8KNxq6UPJqUkCGFRt#yStNUtxgFLFpugHu" +
		"dUQNgI4pGZJookdh25k3YGXofSppfU9d$eBfI2#Dq3dORxnGMLqkxz7T7pHBbuAVj2vs48a" +
		"DmNuelRb$KKLfk8yVtpdGl956#6kcxqEEmVuqAuzSjvYsgZsiHtwFRJrah3SuxttgwzVx3k" +
		"#Q8Q$sr$elbnuKw1yrlZtdGNsZQxDFSwH6X5ID91zavKyBm#d8HXRdI7skeMqxVI9ImpmHS" +
		"IhdZWJhQKb5DMFPcIN27YgZxpA5MOborAoWfHXdIZA7LjgPHNz6BJXZpKPcoS3rJDf2EsYs" +
		"1yjkMkA7RGaTnN5Zn0ZF3xbygRCb5MbUE$SzovVAbpeNfF9dM7uyygNofSxr6VO$aSflVvw" +
		"rZ$3PdBbxAUjKtiWvke$mamlFFtNFflnpr1h7B#rxDZyVfmLfcMUkzACCMcItfjgcBlHtNp" +
		"pFdimpjDhgsLEUhQShtRhj70yA2d5V#uEgzzCz0xI6rjAlz9ktfxnFsy2dgthzMVCvkAVTX" +
		"nuCldVzH#aEKU$sw3OQKLC#q0RkZuCbGtnA4oq3#j$xZ0xzFpnq2uzFgSeNpzcSaxV6jPhq" +
		"OuW8bW6je$NQbvhK99GMl#U6JUXFF$bZkLeqB#kFATXUaFqGc7IzmaIYzOka#tqgsAL4fLQ" +
		"2ZmRVgEfzYSYblWre4N5DaFgTdsoxld1fw1bebujs2PJprr4Qic8FQ2YeCNGc6Dq3G0jHE0" +
		"2#pzi#fXIeTjxwOXhvb9k0gfXoHviZnfGmDbYkC32uDX4LgHTyZOuH5IiE7NN1gu3V0gvqz" +
		"m1$6BmNE4ZzKbEn8OZT4V1fa5Fj4J$HagXueluMBXMluA#xU5t3s$ZKFMtu89kBjZxNnXY#" +
		"oCVFkMZpEVZlHB4LY19hW6U0gfbOteZsVwWoiAr3#OHT7#j6lpu2tXRqfF7rNw$UsBwWiQ3" +
		"nq0bVOz$pYSbRe5seQm62$LXb#m#qGmnY5ndv9KGbIeAlD#VJ$NqlSGNgZXEbr3OuKKvAGX" +
		"UnVpkUYRfBG4NiyxXYXcU1IfhoNI2tAMSY5XF1WJdf9l27GErzTUP5Y2FwjaGp5Eu6VnJyE" +
		"l2NWIq573Wu0NnrEBf2woznqCSlZ9cIoT2DiUIQXRBwPlGoSDZcQn2RIlwohYdmOnokTSO9" +
		"UDmYq6BlzRXL6B#VWiysllpYlHRJ7FLhZ9vacnTHSTrbslw8Ueo5UCoFai$PTQKGFzUhc1i" +
		"VH#PhFCPYaL$1ZRsIRyFUVl1nFcsA#il47VB1B4oTz6cFsCHN1ZqGOEj1v9Bxm1iPMUIJc3" +
		"VDDSpHUEIMk6$1Eu0mPcCKxsIkFuNpwqpvGvHdWxzidyV2NYp6UknYNti1jby$HHpKtFmPz" +
		"dUYF0pb0mxZ#1XHmM6cF1pnmxoAxu#w7qrTHvIFc$98NDyAFf2eq4Mc3laxuHxmTz0Vo4tn" +
		"xwDlqy7XPw5MniyJE9zguesyNdYN4umcvksDlOM6Rm0Mx1RYaHFYJKxWNp2cNi5uMsMVk$e" +
		"1GqzSdmVQJ9I6$1wl$5jcNoUC#VXSFrUWFSPul94jcehoQhkSa0t264#h1gwekbsVXlcVKC" +
		"kqGLwCMQT#bjAStuPpvFo4Eg1hJ5sAuNVauIDoGKnluDW2VZbq8I#bOImbt6tapDo9RGLy$" +
		"RroQNrmhRvfqm1qVR1kLwB$UGB6TCnFABJmgKDEYaL#IsW7tok1DmKXNoLWlKnu4uJu963D" +
		"AJG6kHYnJ0IEDCo5n1TGjmOSEbDTu1X7YV0z3MCWAHvry2Nn8Ch80Ux$m947YsBzJngCiO8" +
		"rEWbZ9$LEyBasZhY7lPYI3gFj4qJ9M7EIonl$bVmtEEy2CZ59HjvYz6qoS1R5s4Zk2dh1N8" +
		"F#ebXdaxk1UfWwZDDOs4pkRf#NKck5oVUbOqBrZnTJifc$fHlRd64lnOo3bEiDnzWeZR6OK" +
		"jrVDkLguqDs7hfbGFlMQ8kzIfpITMrm#vGskEwphehlCGz$G3nNskSq9oy$i5vZxu1T8N6Q" +
		"YK6gLq#fQquU0ofhU5lRVp7HUyqroSIbmybq#EihU8#tx5xhOsUCjnm$95WkheQvDZ#qtjG" +
		"AXZSql9tD2pzgk1bpHNBdWDbR5dl3vcbT31$jhpVjMyD$ywdxq#1F2iRXBcTuhL0uZMtJ9c" +
		"QejovvlAd374okvQsFMPENdW2TZuRPRfp$UVAnlDkccBvt6tzZiSOb70vk5pii7Dl#CZ53R" +
		"9vevbFiyl1bYrnWywGhRLx2xFtIJ9#wRtQAnwlRtTx$lCHyRpcfg#5Vszorthzj779NN5qV" +
		"dDYdY6$yswGqz6dVmASjrbJNI5Dlnd1AH#zrgkujkryoxKoEA#MNyvtvc$YY3xPtRLwmT7Y" +
		"oOd1m7LzeTBmHeltHWBQbZH#ppFbabEUPkgNUTd6h4PjwtdDr$sQtGsuR0Za6jOmy1d6JZN" +
		"si3N478zJHmLjEoTqxh$EvFjBd#XPJjyrRbshoKD96SsxsKV4cLv3mjkKFK5$JESRu6i5r1" +
		"P8Cbdq6C#xJOhgZOFPqZFknU9zxnm9L0tGc19mdUyl9iI7itMxQcRrSWPu#iain3zI#hRUt" +
		"plMWkRRSS7DV6xytVByB30zT7#zpRvDytwdrqEZGzOL3pXV4ia6eUkDN5s#vWDcdkinQ4#E" +
		"pFXSuREfyritK$GRpQpOlOiPJp5Xl6n5mtvUuoFVShajAoHjVKb0EHTtxmNLnpwD#YbqkzO" +
		"MtljJ#l7Jxoxi6USk5TjkyiCzpZ59PmJB9tocEkJyZb4xKF#$VdfkT70CVzPO5zc5oazmWb" +
		"uClbslaJtA5$55TaNFqyMjzPIgkJP8JvGGvNewJNygnFYt6a7d9QNAdt0s#MMwJM#KMELrY" +
		"fopdobtwAkwov72PW#CNSgZypFhCI7MMZrbVMPEjgKJMDD0C4ExiBMYtlWRX3jJw3eJTdmL" +
		"ari$MPWkprFeTjCdQY2FsQTPwQvsrrS8TXlKRw5ThhRMJF2yf92jk$QUFawpfrWwv7QK$SI" +
		"rEnkhQ0$gunx9aYaooPkgpW$guLnRHV9SrMnQMgRAGrbdG#iNI$rd0sYyBo6JKu4mculmlV" +
		"Jr17#EjkHuKCTA5thBaV$A4F2x$bN$BezOyjCUUtreCmXxNGhIjbUe$J2iKyeWyBF#IVyf3" +
		"yg0y8FVBVRZwaxNAmbsTjTHQXkCY4FRHrWAvL#vHqRUMMFDnF6ATiFwszA#CMqT1$rh$w5h" +
		"aVEkOhjsTYyjQO$nOROsplhJ6McEiqTOeQwGrmXfkvLXVMCEiG$hwFjD#YiITY#maEyh7mJ" +
		"#Nm#GxyXEKFf9luuWxVpb8lYb7o67Qwo7w#1vei2wzgu#uJu7KnoOo$J2#rFiD#OXyM3ua7" +
		"vGFeFP#sLRU8##MTyaxPHlTRg4#tY9RoPjbItcJR26RosQogMmY6qlqlRpH4slzwtVIyzy0" +
		"vEKKy99PUcHtWDLbydkvL2wHtyd5Sf5SA1V8#V9R#Or4tyX6e1iyChNrSRci9Vr#EqvMriS" +
		"CStQ1FgRxN2#jZsNqiPGixgal1dA3YieIydfvdMmWwyjhPR8iOAuN118rxYVAA#IZkaR$cf" +
		"oi8clAQl9A8AaXgyjiqxgSBE$HtDPJsXBe#SbVydLeVKs#QezodFVnNEdjDwTUyPHUDlmb7" +
		"T7kaEygdvFFocVaqxABn2vQFWbwNhVf0Uefj#boNpbQZaBC#wFygHme1yZ9SgtSA7#Lg#Kg" +
		"Z$QLycVvc$nTbzKl0jv7Jn67f8667Z7qgA5s8QYzeG66#eAcWAQ2Ef3Gz22nfeT03vEBJe0" +
		"sexmPKBQ0gyXk1TyAlXjyDsJsWEy1$njjbwAiw6UKLr6i$XHoBdqEcS$1XsaID1GyN1fESR" +
		"GQCWkWOm7EVq5PpGprsrPxDRdeAn1cF8XfdoP1Fu3xqXeFnNdASoX6$mB3FCXF0vy6$YMfN" +
		"sXmwU$mA$eDkgQZdQ95cbo4dWSnBTFaeXbeCmDSPR#vg9kFymFW1r2t7rpHMjJz2ldVGNze" +
		"SXaIT13niYbUqnSegr6p3NA7SFqGscq7gLns37L$QXBq8tWWhGEjnxL9iA5#RyCcGN#H$Ui" +
		"N$K3gLpx$nVbaJO96W$lI6DIDqEIYGSGXQMm8UjC1lGTw2$h7WTw7BVLvsBpeRSJZ7SHbFE" +
		"W3b0$3jyEGiqdG4RGv0luJQ0NAAy1dujfCy7VHVWBeGyWEfaIQ2CBw0sBQO0WhBeZr9rvdQ" +
		"NBH9jHjGlaZb8U0FWPz2le4kZu3$mmOr4go0ssEQXAq4jTsWZ#6SqMFUyZbK$QjywVEaE#C" +
		"yTaPM3jJ0c4N0M8QfSb5JyAcBor1$HBOcurhM5T1wlTQXFxDbYuUYgKdqFO9wBKfWPx6kQ9" +
		"dqDwNEaAs4qZz1TucOOZfMV3dG5rHxggvNNuU#f#7BiLxuBm7REQI#lnKJyrTs88noEKXzG" +
		"drNfhxa$hS$KkQk$It1Lu6VmNy5V3UuBt1#u3t0NyL$5LmzIstrs3$TN15tL7N3JoNTZaax" +
		"CH0hB$ZVnpqt$y1JQ1JkW==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};

	private final Action[] actions;

	public JavaParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] literal = INTEGER_LITERAL
			Action.RETURN,	// [1] literal = FLOATING_POINT_LITERAL
			Action.RETURN,	// [2] literal = BOOLEAN_LITERAL
			Action.RETURN,	// [3] literal = CHARACTER_LITERAL
			Action.RETURN,	// [4] literal = STRING_LITERAL
			Action.RETURN,	// [5] literal = NULL_LITERAL
			Action.RETURN,	// [6] type = primitive_type
			Action.RETURN,	// [7] type = reference_type
			Action.RETURN,	// [8] primitive_type = numeric_type
			Action.RETURN,	// [9] primitive_type = BOOLEAN
			Action.RETURN,	// [10] numeric_type = integral_type
			Action.RETURN,	// [11] numeric_type = floating_point_type
			Action.RETURN,	// [12] integral_type = BYTE
			Action.RETURN,	// [13] integral_type = SHORT
			Action.RETURN,	// [14] integral_type = INT
			Action.RETURN,	// [15] integral_type = LONG
			Action.RETURN,	// [16] integral_type = CHAR
			Action.RETURN,	// [17] floating_point_type = FLOAT
			Action.RETURN,	// [18] floating_point_type = DOUBLE
			Action.RETURN,	// [19] reference_type = class_or_interface_type
			Action.RETURN,	// [20] reference_type = array_type
			Action.RETURN,	// [21] class_or_interface_type = name
			Action.RETURN,	// [22] class_type = class_or_interface_type
			Action.RETURN,	// [23] interface_type = class_or_interface_type
			RETURN2,	// [24] array_type = primitive_type dims; returns 'dims' although none is marked
			RETURN2,	// [25] array_type = name dims; returns 'dims' although none is marked
			Action.RETURN,	// [26] name = simple_name
			Action.RETURN,	// [27] name = qualified_name
			Action.RETURN,	// [28] simple_name = IDENTIFIER
			RETURN3,	// [29] qualified_name = name DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [30] compilation_unit = package_declaration_opt import_declarations_opt type_declarations_opt; returns 'type_declarations_opt' although none is marked
			Action.RETURN,	// [31] package_declaration_opt = package_declaration
			Action.NONE,  	// [32] package_declaration_opt = 
			Action.RETURN,	// [33] import_declarations_opt = import_declarations
			Action.NONE,  	// [34] import_declarations_opt = 
			Action.RETURN,	// [35] type_declarations_opt = type_declarations
			Action.NONE,  	// [36] type_declarations_opt = 
			new Action() {	// [37] import_declarations = import_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [38] import_declarations = import_declarations import_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [39] type_declarations = type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [40] type_declarations = type_declarations type_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			RETURN3,	// [41] package_declaration = PACKAGE name SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [42] import_declaration = single_type_import_declaration
			Action.RETURN,	// [43] import_declaration = type_import_on_demand_declaration
			RETURN3,	// [44] single_type_import_declaration = IMPORT name SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [45] type_import_on_demand_declaration = IMPORT name DOT MULT SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [46] type_declaration = class_declaration
			Action.RETURN,	// [47] type_declaration = interface_declaration
			Action.RETURN,	// [48] type_declaration = SEMICOLON
			Action.NONE,  	// [49] modifiers_opt = 
			Action.RETURN,	// [50] modifiers_opt = modifiers
			new Action() {	// [51] modifiers = modifier
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [52] modifiers = modifiers modifier
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [53] modifier = PUBLIC
			Action.RETURN,	// [54] modifier = PROTECTED
			Action.RETURN,	// [55] modifier = PRIVATE
			Action.RETURN,	// [56] modifier = STATIC
			Action.RETURN,	// [57] modifier = ABSTRACT
			Action.RETURN,	// [58] modifier = FINAL
			Action.RETURN,	// [59] modifier = NATIVE
			Action.RETURN,	// [60] modifier = SYNCHRONIZED
			Action.RETURN,	// [61] modifier = TRANSIENT
			Action.RETURN,	// [62] modifier = VOLATILE
			Action.RETURN,	// [63] modifier = STRICTFP
			RETURN6,	// [64] class_declaration = modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body; returns 'class_body' although none is marked
			RETURN2,	// [65] super = EXTENDS class_type; returns 'class_type' although none is marked
			Action.NONE,  	// [66] super_opt = 
			Action.RETURN,	// [67] super_opt = super
			RETURN2,	// [68] interfaces = IMPLEMENTS interface_type_list; returns 'interface_type_list' although none is marked
			Action.NONE,  	// [69] interfaces_opt = 
			Action.RETURN,	// [70] interfaces_opt = interfaces
			new Action() {	// [71] interface_type_list = interface_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [72] interface_type_list = interface_type_list COMMA interface_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			RETURN3,	// [73] class_body = LBRACE class_body_declarations_opt RBRACE; returns 'RBRACE' although none is marked
			Action.NONE,  	// [74] class_body_declarations_opt = 
			Action.RETURN,	// [75] class_body_declarations_opt = class_body_declarations
			new Action() {	// [76] class_body_declarations = class_body_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [77] class_body_declarations = class_body_declarations class_body_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [78] class_body_declaration = class_member_declaration
			Action.RETURN,	// [79] class_body_declaration = static_initializer
			Action.RETURN,	// [80] class_body_declaration = constructor_declaration
			Action.RETURN,	// [81] class_body_declaration = block
			Action.RETURN,	// [82] class_member_declaration = field_declaration
			Action.RETURN,	// [83] class_member_declaration = method_declaration
			RETURN6,	// [84] class_member_declaration = modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt class_body; returns 'class_body' although none is marked
			Action.RETURN,	// [85] class_member_declaration = interface_declaration
			Action.RETURN,	// [86] class_member_declaration = SEMICOLON
			RETURN4,	// [87] field_declaration = modifiers_opt type variable_declarators SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [88] variable_declarators = variable_declarator
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [89] variable_declarators = variable_declarators COMMA variable_declarator
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [90] variable_declarator = variable_declarator_id
			RETURN3,	// [91] variable_declarator = variable_declarator_id EQ variable_initializer; returns 'variable_initializer' although none is marked
			Action.RETURN,	// [92] variable_declarator_id = IDENTIFIER
			RETURN3,	// [93] variable_declarator_id = variable_declarator_id LBRACK RBRACK; returns 'RBRACK' although none is marked
			Action.RETURN,	// [94] variable_initializer = expression
			Action.RETURN,	// [95] variable_initializer = array_initializer
			RETURN2,	// [96] method_declaration = method_header method_body; returns 'method_body' although none is marked
			RETURN4,	// [97] method_header = modifiers_opt type method_declarator throws_opt; returns 'throws_opt' although none is marked
			RETURN4,	// [98] method_header = modifiers_opt VOID method_declarator throws_opt; returns 'throws_opt' although none is marked
			RETURN4,	// [99] method_declarator = IDENTIFIER LPAREN formal_parameter_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [100] method_declarator = method_declarator LBRACK RBRACK; returns 'RBRACK' although none is marked
			Action.NONE,  	// [101] formal_parameter_list_opt = 
			Action.RETURN,	// [102] formal_parameter_list_opt = formal_parameter_list
			new Action() {	// [103] formal_parameter_list = formal_parameter
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [104] formal_parameter_list = formal_parameter_list COMMA formal_parameter
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			RETURN2,	// [105] formal_parameter = type variable_declarator_id; returns 'variable_declarator_id' although none is marked
			RETURN3,	// [106] formal_parameter = FINAL type variable_declarator_id; returns 'variable_declarator_id' although none is marked
			Action.NONE,  	// [107] throws_opt = 
			Action.RETURN,	// [108] throws_opt = throws
			RETURN2,	// [109] throws = THROWS class_type_list; returns 'class_type_list' although none is marked
			new Action() {	// [110] class_type_list = class_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [111] class_type_list = class_type_list COMMA class_type
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [112] method_body = block
			Action.RETURN,	// [113] method_body = SEMICOLON
			RETURN2,	// [114] static_initializer = STATIC block; returns 'block' although none is marked
			RETURN4,	// [115] constructor_declaration = modifiers_opt constructor_declarator throws_opt constructor_body; returns 'constructor_body' although none is marked
			RETURN4,	// [116] constructor_declarator = simple_name LPAREN formal_parameter_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN4,	// [117] constructor_body = LBRACE explicit_constructor_invocation block_statements RBRACE; returns 'RBRACE' although none is marked
			RETURN3,	// [118] constructor_body = LBRACE explicit_constructor_invocation RBRACE; returns 'RBRACE' although none is marked
			RETURN3,	// [119] constructor_body = LBRACE block_statements RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [120] constructor_body = LBRACE RBRACE; returns 'RBRACE' although none is marked
			RETURN5,	// [121] explicit_constructor_invocation = THIS LPAREN argument_list_opt RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [122] explicit_constructor_invocation = SUPER LPAREN argument_list_opt RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN7,	// [123] explicit_constructor_invocation = primary DOT THIS LPAREN argument_list_opt RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN7,	// [124] explicit_constructor_invocation = primary DOT SUPER LPAREN argument_list_opt RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [125] interface_declaration = modifiers_opt INTERFACE IDENTIFIER extends_interfaces_opt interface_body; returns 'interface_body' although none is marked
			Action.NONE,  	// [126] extends_interfaces_opt = 
			Action.RETURN,	// [127] extends_interfaces_opt = extends_interfaces
			RETURN2,	// [128] extends_interfaces = EXTENDS interface_type; returns 'interface_type' although none is marked
			RETURN3,	// [129] extends_interfaces = extends_interfaces COMMA interface_type; returns 'interface_type' although none is marked
			RETURN3,	// [130] interface_body = LBRACE interface_member_declarations_opt RBRACE; returns 'RBRACE' although none is marked
			Action.NONE,  	// [131] interface_member_declarations_opt = 
			Action.RETURN,	// [132] interface_member_declarations_opt = interface_member_declarations
			new Action() {	// [133] interface_member_declarations = interface_member_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [134] interface_member_declarations = interface_member_declarations interface_member_declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [135] interface_member_declaration = constant_declaration
			Action.RETURN,	// [136] interface_member_declaration = abstract_method_declaration
			Action.RETURN,	// [137] interface_member_declaration = class_declaration
			Action.RETURN,	// [138] interface_member_declaration = interface_declaration
			Action.RETURN,	// [139] interface_member_declaration = SEMICOLON
			Action.RETURN,	// [140] constant_declaration = field_declaration
			RETURN2,	// [141] abstract_method_declaration = method_header SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN4,	// [142] array_initializer = LBRACE variable_initializers COMMA RBRACE; returns 'RBRACE' although none is marked
			RETURN3,	// [143] array_initializer = LBRACE variable_initializers RBRACE; returns 'RBRACE' although none is marked
			RETURN3,	// [144] array_initializer = LBRACE COMMA RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [145] array_initializer = LBRACE RBRACE; returns 'RBRACE' although none is marked
			new Action() {	// [146] variable_initializers = variable_initializer
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [147] variable_initializers = variable_initializers COMMA variable_initializer
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			RETURN3,	// [148] block = LBRACE block_statements_opt RBRACE; returns 'RBRACE' although none is marked
			Action.NONE,  	// [149] block_statements_opt = 
			Action.RETURN,	// [150] block_statements_opt = block_statements
			new Action() {	// [151] block_statements = block_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [152] block_statements = block_statements block_statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [153] block_statement = local_variable_declaration_statement
			Action.RETURN,	// [154] block_statement = statement
			Action.RETURN,	// [155] block_statement = class_declaration
			Action.RETURN,	// [156] block_statement = interface_declaration
			RETURN2,	// [157] local_variable_declaration_statement = local_variable_declaration SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [158] local_variable_declaration = type variable_declarators; returns 'variable_declarators' although none is marked
			RETURN3,	// [159] local_variable_declaration = FINAL type variable_declarators; returns 'variable_declarators' although none is marked
			Action.RETURN,	// [160] statement = statement_without_trailing_substatement
			Action.RETURN,	// [161] statement = labeled_statement
			Action.RETURN,	// [162] statement = if_then_statement
			Action.RETURN,	// [163] statement = if_then_else_statement
			Action.RETURN,	// [164] statement = while_statement
			Action.RETURN,	// [165] statement = for_statement
			Action.RETURN,	// [166] statement_no_short_if = statement_without_trailing_substatement
			Action.RETURN,	// [167] statement_no_short_if = labeled_statement_no_short_if
			Action.RETURN,	// [168] statement_no_short_if = if_then_else_statement_no_short_if
			Action.RETURN,	// [169] statement_no_short_if = while_statement_no_short_if
			Action.RETURN,	// [170] statement_no_short_if = for_statement_no_short_if
			Action.RETURN,	// [171] statement_without_trailing_substatement = block
			Action.RETURN,	// [172] statement_without_trailing_substatement = empty_statement
			Action.RETURN,	// [173] statement_without_trailing_substatement = expression_statement
			Action.RETURN,	// [174] statement_without_trailing_substatement = switch_statement
			Action.RETURN,	// [175] statement_without_trailing_substatement = do_statement
			Action.RETURN,	// [176] statement_without_trailing_substatement = break_statement
			Action.RETURN,	// [177] statement_without_trailing_substatement = continue_statement
			Action.RETURN,	// [178] statement_without_trailing_substatement = return_statement
			Action.RETURN,	// [179] statement_without_trailing_substatement = synchronized_statement
			Action.RETURN,	// [180] statement_without_trailing_substatement = throw_statement
			Action.RETURN,	// [181] statement_without_trailing_substatement = try_statement
			Action.RETURN,	// [182] empty_statement = SEMICOLON
			RETURN3,	// [183] labeled_statement = IDENTIFIER COLON statement; returns 'statement' although none is marked
			RETURN3,	// [184] labeled_statement_no_short_if = IDENTIFIER COLON statement_no_short_if; returns 'statement_no_short_if' although none is marked
			RETURN2,	// [185] expression_statement = statement_expression SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [186] statement_expression = assignment
			Action.RETURN,	// [187] statement_expression = preincrement_expression
			Action.RETURN,	// [188] statement_expression = predecrement_expression
			Action.RETURN,	// [189] statement_expression = postincrement_expression
			Action.RETURN,	// [190] statement_expression = postdecrement_expression
			Action.RETURN,	// [191] statement_expression = method_invocation
			Action.RETURN,	// [192] statement_expression = class_instance_creation_expression
			RETURN5,	// [193] if_then_statement = IF LPAREN expression RPAREN statement; returns 'statement' although none is marked
			RETURN7,	// [194] if_then_else_statement = IF LPAREN expression RPAREN statement_no_short_if ELSE statement; returns 'statement' although none is marked
			RETURN7,	// [195] if_then_else_statement_no_short_if = IF LPAREN expression RPAREN statement_no_short_if ELSE statement_no_short_if; returns 'statement_no_short_if' although none is marked
			RETURN5,	// [196] switch_statement = SWITCH LPAREN expression RPAREN switch_block; returns 'switch_block' although none is marked
			RETURN4,	// [197] switch_block = LBRACE switch_block_statement_groups switch_labels RBRACE; returns 'RBRACE' although none is marked
			RETURN3,	// [198] switch_block = LBRACE switch_block_statement_groups RBRACE; returns 'RBRACE' although none is marked
			RETURN3,	// [199] switch_block = LBRACE switch_labels RBRACE; returns 'RBRACE' although none is marked
			RETURN2,	// [200] switch_block = LBRACE RBRACE; returns 'RBRACE' although none is marked
			new Action() {	// [201] switch_block_statement_groups = switch_block_statement_group
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [202] switch_block_statement_groups = switch_block_statement_groups switch_block_statement_group
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			RETURN2,	// [203] switch_block_statement_group = switch_labels block_statements; returns 'block_statements' although none is marked
			new Action() {	// [204] switch_labels = switch_label
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [205] switch_labels = switch_labels switch_label
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			RETURN3,	// [206] switch_label = CASE constant_expression COLON; returns 'COLON' although none is marked
			RETURN2,	// [207] switch_label = DEFAULT COLON; returns 'COLON' although none is marked
			RETURN5,	// [208] while_statement = WHILE LPAREN expression RPAREN statement; returns 'statement' although none is marked
			RETURN5,	// [209] while_statement_no_short_if = WHILE LPAREN expression RPAREN statement_no_short_if; returns 'statement_no_short_if' although none is marked
			RETURN7,	// [210] do_statement = DO statement WHILE LPAREN expression RPAREN SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN9,	// [211] for_statement = FOR LPAREN for_init_opt SEMICOLON expression_opt SEMICOLON for_update_opt RPAREN statement; returns 'statement' although none is marked
			RETURN9,	// [212] for_statement_no_short_if = FOR LPAREN for_init_opt SEMICOLON expression_opt SEMICOLON for_update_opt RPAREN statement_no_short_if; returns 'statement_no_short_if' although none is marked
			Action.NONE,  	// [213] for_init_opt = 
			Action.RETURN,	// [214] for_init_opt = for_init
			Action.RETURN,	// [215] for_init = statement_expression_list
			Action.RETURN,	// [216] for_init = local_variable_declaration
			Action.NONE,  	// [217] for_update_opt = 
			Action.RETURN,	// [218] for_update_opt = for_update
			Action.RETURN,	// [219] for_update = statement_expression_list
			new Action() {	// [220] statement_expression_list = statement_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [221] statement_expression_list = statement_expression_list COMMA statement_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [222] identifier_opt = 
			Action.RETURN,	// [223] identifier_opt = IDENTIFIER
			RETURN3,	// [224] break_statement = BREAK identifier_opt SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [225] continue_statement = CONTINUE identifier_opt SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [226] return_statement = RETURN expression_opt SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [227] throw_statement = THROW expression SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN5,	// [228] synchronized_statement = SYNCHRONIZED LPAREN expression RPAREN block; returns 'block' although none is marked
			RETURN3,	// [229] try_statement = TRY block catches; returns 'catches' although none is marked
			RETURN4,	// [230] try_statement = TRY block catches_opt finally; returns 'finally' although none is marked
			Action.NONE,  	// [231] catches_opt = 
			Action.RETURN,	// [232] catches_opt = catches
			new Action() {	// [233] catches = catch_clause
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [234] catches = catches catch_clause
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			RETURN5,	// [235] catch_clause = CATCH LPAREN formal_parameter RPAREN block; returns 'block' although none is marked
			RETURN2,	// [236] finally = FINALLY block; returns 'block' although none is marked
			Action.RETURN,	// [237] primary = primary_no_new_array
			Action.RETURN,	// [238] primary = array_creation_expression
			Action.RETURN,	// [239] primary_no_new_array = literal
			Action.RETURN,	// [240] primary_no_new_array = THIS
			RETURN3,	// [241] primary_no_new_array = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			Action.RETURN,	// [242] primary_no_new_array = class_instance_creation_expression
			Action.RETURN,	// [243] primary_no_new_array = field_access
			Action.RETURN,	// [244] primary_no_new_array = method_invocation
			Action.RETURN,	// [245] primary_no_new_array = array_access
			RETURN3,	// [246] primary_no_new_array = primitive_type DOT CLASS; returns 'CLASS' although none is marked
			RETURN3,	// [247] primary_no_new_array = VOID DOT CLASS; returns 'CLASS' although none is marked
			RETURN3,	// [248] primary_no_new_array = array_type DOT CLASS; returns 'CLASS' although none is marked
			RETURN3,	// [249] primary_no_new_array = name DOT CLASS; returns 'CLASS' although none is marked
			RETURN3,	// [250] primary_no_new_array = name DOT THIS; returns 'THIS' although none is marked
			RETURN5,	// [251] class_instance_creation_expression = NEW class_type LPAREN argument_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN6,	// [252] class_instance_creation_expression = NEW class_type LPAREN argument_list_opt RPAREN class_body; returns 'class_body' although none is marked
			RETURN7,	// [253] class_instance_creation_expression = primary DOT NEW IDENTIFIER LPAREN argument_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN8,	// [254] class_instance_creation_expression = primary DOT NEW IDENTIFIER LPAREN argument_list_opt RPAREN class_body; returns 'class_body' although none is marked
			Action.NONE,  	// [255] argument_list_opt = 
			Action.RETURN,	// [256] argument_list_opt = argument_list
			new Action() {	// [257] argument_list = expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [258] argument_list = argument_list COMMA expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			RETURN4,	// [259] array_creation_expression = NEW primitive_type dim_exprs dims_opt; returns 'dims_opt' although none is marked
			RETURN4,	// [260] array_creation_expression = NEW class_or_interface_type dim_exprs dims_opt; returns 'dims_opt' although none is marked
			RETURN4,	// [261] array_creation_expression = NEW primitive_type dims array_initializer; returns 'array_initializer' although none is marked
			RETURN4,	// [262] array_creation_expression = NEW class_or_interface_type dims array_initializer; returns 'array_initializer' although none is marked
			new Action() {	// [263] dim_exprs = dim_expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [264] dim_exprs = dim_exprs dim_expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			RETURN3,	// [265] dim_expr = LBRACK expression RBRACK; returns 'RBRACK' although none is marked
			Action.NONE,  	// [266] dims_opt = 
			Action.RETURN,	// [267] dims_opt = dims
			RETURN2,	// [268] dims = LBRACK RBRACK; returns 'RBRACK' although none is marked
			RETURN3,	// [269] dims = dims LBRACK RBRACK; returns 'RBRACK' although none is marked
			RETURN3,	// [270] field_access = primary DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN3,	// [271] field_access = SUPER DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN5,	// [272] field_access = name DOT SUPER DOT IDENTIFIER; returns 'IDENTIFIER' although none is marked
			RETURN4,	// [273] method_invocation = name LPAREN argument_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN6,	// [274] method_invocation = primary DOT IDENTIFIER LPAREN argument_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN6,	// [275] method_invocation = SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN8,	// [276] method_invocation = name DOT SUPER DOT IDENTIFIER LPAREN argument_list_opt RPAREN; returns 'RPAREN' although none is marked
			RETURN4,	// [277] array_access = name LBRACK expression RBRACK; returns 'RBRACK' although none is marked
			RETURN4,	// [278] array_access = primary_no_new_array LBRACK expression RBRACK; returns 'RBRACK' although none is marked
			Action.RETURN,	// [279] postfix_expression = primary
			Action.RETURN,	// [280] postfix_expression = name
			Action.RETURN,	// [281] postfix_expression = postincrement_expression
			Action.RETURN,	// [282] postfix_expression = postdecrement_expression
			RETURN2,	// [283] postincrement_expression = postfix_expression PLUSPLUS; returns 'PLUSPLUS' although none is marked
			RETURN2,	// [284] postdecrement_expression = postfix_expression MINUSMINUS; returns 'MINUSMINUS' although none is marked
			Action.RETURN,	// [285] unary_expression = preincrement_expression
			Action.RETURN,	// [286] unary_expression = predecrement_expression
			RETURN2,	// [287] unary_expression = PLUS unary_expression; returns 'unary_expression' although none is marked
			RETURN2,	// [288] unary_expression = MINUS unary_expression; returns 'unary_expression' although none is marked
			Action.RETURN,	// [289] unary_expression = unary_expression_not_plus_minus
			RETURN2,	// [290] preincrement_expression = PLUSPLUS unary_expression; returns 'unary_expression' although none is marked
			RETURN2,	// [291] predecrement_expression = MINUSMINUS unary_expression; returns 'unary_expression' although none is marked
			Action.RETURN,	// [292] unary_expression_not_plus_minus = postfix_expression
			RETURN2,	// [293] unary_expression_not_plus_minus = COMP unary_expression; returns 'unary_expression' although none is marked
			RETURN2,	// [294] unary_expression_not_plus_minus = NOT unary_expression; returns 'unary_expression' although none is marked
			Action.RETURN,	// [295] unary_expression_not_plus_minus = cast_expression
			RETURN5,	// [296] cast_expression = LPAREN primitive_type dims_opt RPAREN unary_expression; returns 'unary_expression' although none is marked
			RETURN4,	// [297] cast_expression = LPAREN expression RPAREN unary_expression_not_plus_minus; returns 'unary_expression_not_plus_minus' although none is marked
			RETURN5,	// [298] cast_expression = LPAREN name dims RPAREN unary_expression_not_plus_minus; returns 'unary_expression_not_plus_minus' although none is marked
			Action.RETURN,	// [299] multiplicative_expression = unary_expression
			RETURN3,	// [300] multiplicative_expression = multiplicative_expression MULT unary_expression; returns 'unary_expression' although none is marked
			RETURN3,	// [301] multiplicative_expression = multiplicative_expression DIV unary_expression; returns 'unary_expression' although none is marked
			RETURN3,	// [302] multiplicative_expression = multiplicative_expression MOD unary_expression; returns 'unary_expression' although none is marked
			Action.RETURN,	// [303] additive_expression = multiplicative_expression
			RETURN3,	// [304] additive_expression = additive_expression PLUS multiplicative_expression; returns 'multiplicative_expression' although none is marked
			RETURN3,	// [305] additive_expression = additive_expression MINUS multiplicative_expression; returns 'multiplicative_expression' although none is marked
			Action.RETURN,	// [306] shift_expression = additive_expression
			RETURN3,	// [307] shift_expression = shift_expression LSHIFT additive_expression; returns 'additive_expression' although none is marked
			RETURN3,	// [308] shift_expression = shift_expression RSHIFT additive_expression; returns 'additive_expression' although none is marked
			RETURN3,	// [309] shift_expression = shift_expression URSHIFT additive_expression; returns 'additive_expression' although none is marked
			Action.RETURN,	// [310] relational_expression = shift_expression
			RETURN3,	// [311] relational_expression = relational_expression LT shift_expression; returns 'shift_expression' although none is marked
			RETURN3,	// [312] relational_expression = relational_expression GT shift_expression; returns 'shift_expression' although none is marked
			RETURN3,	// [313] relational_expression = relational_expression LTEQ shift_expression; returns 'shift_expression' although none is marked
			RETURN3,	// [314] relational_expression = relational_expression GTEQ shift_expression; returns 'shift_expression' although none is marked
			RETURN3,	// [315] relational_expression = relational_expression INSTANCEOF reference_type; returns 'reference_type' although none is marked
			Action.RETURN,	// [316] equality_expression = relational_expression
			RETURN3,	// [317] equality_expression = equality_expression EQEQ relational_expression; returns 'relational_expression' although none is marked
			RETURN3,	// [318] equality_expression = equality_expression NOTEQ relational_expression; returns 'relational_expression' although none is marked
			new Action() {	// [319] and_expression = equality_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [320] and_expression = and_expression AND equality_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [321] exclusive_or_expression = and_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [322] exclusive_or_expression = exclusive_or_expression XOR and_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [323] inclusive_or_expression = exclusive_or_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [324] inclusive_or_expression = inclusive_or_expression OR exclusive_or_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [325] conditional_and_expression = inclusive_or_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [326] conditional_and_expression = conditional_and_expression ANDAND inclusive_or_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [327] conditional_or_expression = conditional_and_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [328] conditional_or_expression = conditional_or_expression OROR conditional_and_expression
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			Action.RETURN,	// [329] conditional_expression = conditional_or_expression
			RETURN5,	// [330] conditional_expression = conditional_or_expression QUESTION expression COLON conditional_expression; returns 'conditional_expression' although none is marked
			Action.RETURN,	// [331] assignment_expression = conditional_expression
			Action.RETURN,	// [332] assignment_expression = assignment
			RETURN3,	// [333] assignment = left_hand_side assignment_operator assignment_expression; returns 'assignment_expression' although none is marked
			Action.RETURN,	// [334] left_hand_side = name
			Action.RETURN,	// [335] left_hand_side = field_access
			Action.RETURN,	// [336] left_hand_side = array_access
			Action.RETURN,	// [337] assignment_operator = EQ
			Action.RETURN,	// [338] assignment_operator = MULTEQ
			Action.RETURN,	// [339] assignment_operator = DIVEQ
			Action.RETURN,	// [340] assignment_operator = MODEQ
			Action.RETURN,	// [341] assignment_operator = PLUSEQ
			Action.RETURN,	// [342] assignment_operator = MINUSEQ
			Action.RETURN,	// [343] assignment_operator = LSHIFTEQ
			Action.RETURN,	// [344] assignment_operator = RSHIFTEQ
			Action.RETURN,	// [345] assignment_operator = URSHIFTEQ
			Action.RETURN,	// [346] assignment_operator = ANDEQ
			Action.RETURN,	// [347] assignment_operator = XOREQ
			Action.RETURN,	// [348] assignment_operator = OREQ
			Action.NONE,  	// [349] expression_opt = 
			Action.RETURN,	// [350] expression_opt = expression
			Action.RETURN,	// [351] expression = assignment_expression
			Action.RETURN	// [352] constant_expression = expression
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
